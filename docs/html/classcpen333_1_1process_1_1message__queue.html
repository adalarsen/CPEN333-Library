<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CPEN333: Process and Threads Library: cpen333::process::message_queue&lt; MessageType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CPEN333: Process and Threads Library
   &#160;<span id="projectnumber">1.1</span>
   </div>
   <div id="projectbrief">Cross-platform library for inter-process and inter-thread synchronization and communication</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cpen333</b></li><li class="navelem"><b>process</b></li><li class="navelem"><a class="el" href="classcpen333_1_1process_1_1message__queue.html">message_queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcpen333_1_1process_1_1message__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cpen333::process::message_queue&lt; MessageType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic inter-process named message queue based on a FIFO.  
 <a href="classcpen333_1_1process_1_1message__queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="message__queue_8h_source.html">message_queue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cpen333::process::message_queue&lt; MessageType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcpen333_1_1process_1_1message__queue.png" usemap="#cpen333::process::message_5Fqueue_3C_20MessageType_20_3E_map" alt=""/>
  <map id="cpen333::process::message_5Fqueue_3C_20MessageType_20_3E_map" name="cpen333::process::message_5Fqueue_3C_20MessageType_20_3E_map">
<area href="classcpen333_1_1process_1_1named__resource.html" title="Pure virtual base class for all inter-process resources. " alt="cpen333::process::named_resource" shape="rect" coords="0,0,311,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a846d3e301643761369a88933f3fb282b"><td class="memItemLeft" align="right" valign="top"><a id="a846d3e301643761369a88933f3fb282b"></a>
typedef MessageType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#a846d3e301643761369a88933f3fb282b">message_type</a></td></tr>
<tr class="memdesc:a846d3e301643761369a88933f3fb282b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message type. <br /></td></tr>
<tr class="separator:a846d3e301643761369a88933f3fb282b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3312decb9ec69e323ba97f321125d348"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#a3312decb9ec69e323ba97f321125d348">message_queue</a> (const std::string &amp;name, size_t <a class="el" href="classcpen333_1_1process_1_1message__queue.html#aab604a8c153f7f918762abc7f2380396">size</a>=1024)</td></tr>
<tr class="memdesc:a3312decb9ec69e323ba97f321125d348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a named message queue.  <a href="#a3312decb9ec69e323ba97f321125d348">More...</a><br /></td></tr>
<tr class="separator:a3312decb9ec69e323ba97f321125d348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f50c208f75ad2937d11d7eca8fdb6f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#a1f50c208f75ad2937d11d7eca8fdb6f0">send</a> (const MessageType &amp;msg)</td></tr>
<tr class="memdesc:a1f50c208f75ad2937d11d7eca8fdb6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to the queue.  <a href="#a1f50c208f75ad2937d11d7eca8fdb6f0">More...</a><br /></td></tr>
<tr class="separator:a1f50c208f75ad2937d11d7eca8fdb6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae632a2b200bdac5bc93039b9bcb3d7f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#ae632a2b200bdac5bc93039b9bcb3d7f5">try_send</a> (const MessageType &amp;msg)</td></tr>
<tr class="memdesc:ae632a2b200bdac5bc93039b9bcb3d7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to send a message without blocking.  <a href="#ae632a2b200bdac5bc93039b9bcb3d7f5">More...</a><br /></td></tr>
<tr class="separator:ae632a2b200bdac5bc93039b9bcb3d7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5242a6193a42e68e36634846f09c5e3b"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a5242a6193a42e68e36634846f09c5e3b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#a5242a6193a42e68e36634846f09c5e3b">try_send_for</a> (const MessageType &amp;msg, std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</td></tr>
<tr class="memdesc:a5242a6193a42e68e36634846f09c5e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to send a message, will wait for a maximum amount of time before aborting.  <a href="#a5242a6193a42e68e36634846f09c5e3b">More...</a><br /></td></tr>
<tr class="separator:a5242a6193a42e68e36634846f09c5e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13d8f1c89ca9022e5446b3fc5432072"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename Duration &gt; </td></tr>
<tr class="memitem:ab13d8f1c89ca9022e5446b3fc5432072"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#ab13d8f1c89ca9022e5446b3fc5432072">try_send_until</a> (const MessageType &amp;msg, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout)</td></tr>
<tr class="memdesc:ab13d8f1c89ca9022e5446b3fc5432072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to send a message, will wait until a timeout time has been reached before aborting.  <a href="#ab13d8f1c89ca9022e5446b3fc5432072">More...</a><br /></td></tr>
<tr class="separator:ab13d8f1c89ca9022e5446b3fc5432072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d2e54480fba6a441e70cb1362d3900"><td class="memItemLeft" align="right" valign="top">MessageType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#a39d2e54480fba6a441e70cb1362d3900">receive</a> ()</td></tr>
<tr class="memdesc:a39d2e54480fba6a441e70cb1362d3900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves and removes the next message from the message queue.  <a href="#a39d2e54480fba6a441e70cb1362d3900">More...</a><br /></td></tr>
<tr class="separator:a39d2e54480fba6a441e70cb1362d3900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eccb93a61129e6e6dec2db5f5b1f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#a63eccb93a61129e6e6dec2db5f5b1f2b">receive</a> (MessageType *out)</td></tr>
<tr class="memdesc:a63eccb93a61129e6e6dec2db5f5b1f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves and removes the next message from the message queue.  <a href="#a63eccb93a61129e6e6dec2db5f5b1f2b">More...</a><br /></td></tr>
<tr class="separator:a63eccb93a61129e6e6dec2db5f5b1f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42a9bd9edc9753a38fa63f20a34cc60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#ae42a9bd9edc9753a38fa63f20a34cc60">try_receive</a> (MessageType *out)</td></tr>
<tr class="memdesc:ae42a9bd9edc9753a38fa63f20a34cc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to receive a message without blocking.  <a href="#ae42a9bd9edc9753a38fa63f20a34cc60">More...</a><br /></td></tr>
<tr class="separator:ae42a9bd9edc9753a38fa63f20a34cc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4264047863208a01109569f62d093885"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a4264047863208a01109569f62d093885"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#a4264047863208a01109569f62d093885">try_receive_for</a> (MessageType *out, std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</td></tr>
<tr class="memdesc:a4264047863208a01109569f62d093885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to receive a message, will wait for a maximum amount of time before aborting.  <a href="#a4264047863208a01109569f62d093885">More...</a><br /></td></tr>
<tr class="separator:a4264047863208a01109569f62d093885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf193426822dfbb27fc1ce972db42da0"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename Duration &gt; </td></tr>
<tr class="memitem:abf193426822dfbb27fc1ce972db42da0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#abf193426822dfbb27fc1ce972db42da0">try_receive_until</a> (MessageType *out, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout)</td></tr>
<tr class="memdesc:abf193426822dfbb27fc1ce972db42da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to receive a message, will wait for a maximum timeout time to be reached before aborting.  <a href="#abf193426822dfbb27fc1ce972db42da0">More...</a><br /></td></tr>
<tr class="separator:abf193426822dfbb27fc1ce972db42da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e2c27bc1fe660b573129f7518ecec7"><td class="memItemLeft" align="right" valign="top">MessageType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#a22e2c27bc1fe660b573129f7518ecec7">peek</a> ()</td></tr>
<tr class="memdesc:a22e2c27bc1fe660b573129f7518ecec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks at the next message without removing it.  <a href="#a22e2c27bc1fe660b573129f7518ecec7">More...</a><br /></td></tr>
<tr class="separator:a22e2c27bc1fe660b573129f7518ecec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6f0bb9911b01f601bb67551007be3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#a0d6f0bb9911b01f601bb67551007be3d">peek</a> (MessageType *out)</td></tr>
<tr class="memdesc:a0d6f0bb9911b01f601bb67551007be3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks at the next message without removing it.  <a href="#a0d6f0bb9911b01f601bb67551007be3d">More...</a><br /></td></tr>
<tr class="separator:a0d6f0bb9911b01f601bb67551007be3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344d81de71e73ab318d2bf4a4a852a1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#a344d81de71e73ab318d2bf4a4a852a1b">try_peek</a> (MessageType *out)</td></tr>
<tr class="memdesc:a344d81de71e73ab318d2bf4a4a852a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to peek at the message without blocking.  <a href="#a344d81de71e73ab318d2bf4a4a852a1b">More...</a><br /></td></tr>
<tr class="separator:a344d81de71e73ab318d2bf4a4a852a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62077115caee87a6eccd527924015748"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a62077115caee87a6eccd527924015748"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#a62077115caee87a6eccd527924015748">try_peek_for</a> (MessageType *out, std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</td></tr>
<tr class="memdesc:a62077115caee87a6eccd527924015748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to peek at the next message, will wait for a maximum amount of time before aborting.  <a href="#a62077115caee87a6eccd527924015748">More...</a><br /></td></tr>
<tr class="separator:a62077115caee87a6eccd527924015748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae518346095033df725270dfeb866cdb4"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename Duration &gt; </td></tr>
<tr class="memitem:ae518346095033df725270dfeb866cdb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#ae518346095033df725270dfeb866cdb4">try_peek_until</a> (MessageType *out, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout)</td></tr>
<tr class="memdesc:ae518346095033df725270dfeb866cdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to peek at the next message, will wait for a maximum timeout time before aborting.  <a href="#ae518346095033df725270dfeb866cdb4">More...</a><br /></td></tr>
<tr class="separator:ae518346095033df725270dfeb866cdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab604a8c153f7f918762abc7f2380396"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#aab604a8c153f7f918762abc7f2380396">size</a> ()</td></tr>
<tr class="memdesc:aab604a8c153f7f918762abc7f2380396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of messages currently in the queue.  <a href="#aab604a8c153f7f918762abc7f2380396">More...</a><br /></td></tr>
<tr class="separator:aab604a8c153f7f918762abc7f2380396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321bee9b732f97362172c6c4ee8226a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#a321bee9b732f97362172c6c4ee8226a4">empty</a> ()</td></tr>
<tr class="memdesc:a321bee9b732f97362172c6c4ee8226a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the message queue is currently empty.  <a href="#a321bee9b732f97362172c6c4ee8226a4">More...</a><br /></td></tr>
<tr class="separator:a321bee9b732f97362172c6c4ee8226a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94a6503dff948dfc2533f7786839dca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#ae94a6503dff948dfc2533f7786839dca">unlink</a> ()</td></tr>
<tr class="memdesc:ae94a6503dff948dfc2533f7786839dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the name from the named resource.  <a href="#ae94a6503dff948dfc2533f7786839dca">More...</a><br /></td></tr>
<tr class="separator:ae94a6503dff948dfc2533f7786839dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcpen333_1_1process_1_1named__resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcpen333_1_1process_1_1named__resource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcpen333_1_1process_1_1named__resource.html">cpen333::process::named_resource</a></td></tr>
<tr class="memitem:a2bf88d9fa295c5e9ffecf2a43414e6da inherit pub_methods_classcpen333_1_1process_1_1named__resource"><td class="memItemLeft" align="right" valign="top"><a id="a2bf88d9fa295c5e9ffecf2a43414e6da"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1named__resource.html#a2bf88d9fa295c5e9ffecf2a43414e6da">~named_resource</a> ()</td></tr>
<tr class="memdesc:a2bf88d9fa295c5e9ffecf2a43414e6da inherit pub_methods_classcpen333_1_1process_1_1named__resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:a2bf88d9fa295c5e9ffecf2a43414e6da inherit pub_methods_classcpen333_1_1process_1_1named__resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aca172436d5b30c250c301d3c224598b6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1message__queue.html#aca172436d5b30c250c301d3c224598b6">unlink</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aca172436d5b30c250c301d3c224598b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the name without needing to create a resource.  <a href="#aca172436d5b30c250c301d3c224598b6">More...</a><br /></td></tr>
<tr class="separator:aca172436d5b30c250c301d3c224598b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classcpen333_1_1process_1_1named__resource"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classcpen333_1_1process_1_1named__resource')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classcpen333_1_1process_1_1named__resource.html">cpen333::process::named_resource</a></td></tr>
<tr class="memitem:a6cb427f033b51f08fcf2bc1e08bd6a32 inherit pub_static_methods_classcpen333_1_1process_1_1named__resource"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1named__resource.html#a6cb427f033b51f08fcf2bc1e08bd6a32">unlink</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6cb427f033b51f08fcf2bc1e08bd6a32 inherit pub_static_methods_classcpen333_1_1process_1_1named__resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the name without needing to create a resource.  <a href="classcpen333_1_1process_1_1named__resource.html#a6cb427f033b51f08fcf2bc1e08bd6a32">More...</a><br /></td></tr>
<tr class="separator:a6cb427f033b51f08fcf2bc1e08bd6a32 inherit pub_static_methods_classcpen333_1_1process_1_1named__resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MessageType&gt;<br />
class cpen333::process::message_queue&lt; MessageType &gt;</h3>

<p>Basic inter-process named message queue based on a FIFO. </p>
<p>Allows sending/receiving of messages with a fixed type. Unlike Windows messages, does not require you to know the thread ID of the receiver, but also does not allow filtering on the receiving end. Unlike a POSIX message queue, does not allow variable length messages or message priorities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MessageType</td><td>fixed type of messages. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3312decb9ec69e323ba97f321125d348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3312decb9ec69e323ba97f321125d348">&#9670;&nbsp;</a></span>message_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::<a class="el" href="classcpen333_1_1process_1_1message__queue.html">message_queue</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a named message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name identifier for creating or connecting to an existing inter-process message-queue </td></tr>
    <tr><td class="paramname">size</td><td>if creating, the maximum number of elements that can be stored in the queue without blocking </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a321bee9b732f97362172c6c4ee8226a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321bee9b732f97362172c6c4ee8226a4">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the message queue is currently empty. </p>
<p>This method should be used sparingly, since messages could be added/removed during or immediately after the call, making the result potentially unreliable</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if empty, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a22e2c27bc1fe660b573129f7518ecec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e2c27bc1fe660b573129f7518ecec7">&#9670;&nbsp;</a></span>peek() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MessageType <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peeks at the next message without removing it. </p>
<p>Returns the next message in the queue. If there are currently no messages, this method will block until one becomes available. The message will remain in the queue for the next <code>peek</code> or <code>receive</code> operation.</p>
<dl class="section return"><dt>Returns</dt><dd>next message in the queue </dd></dl>

</div>
</div>
<a id="a0d6f0bb9911b01f601bb67551007be3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6f0bb9911b01f601bb67551007be3d">&#9670;&nbsp;</a></span>peek() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::peek </td>
          <td>(</td>
          <td class="paramtype">MessageType *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peeks at the next message without removing it. </p>
<p>Populates memory pointed to by <code>out</code> with next message in the queue. If there are currently no messages, this method will block until a message becomes available. The message will remain in the queue for the next <code>peek</code> or <code>receive</code> operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, nothing happens. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39d2e54480fba6a441e70cb1362d3900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d2e54480fba6a441e70cb1362d3900">&#9670;&nbsp;</a></span>receive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MessageType <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::receive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves and removes the next message from the message queue. </p>
<p>If there are currently no messages in the queue, then the current thread will block until a message becomes available.</p>
<dl class="section return"><dt>Returns</dt><dd>the next message in the queue </dd></dl>

</div>
</div>
<a id="a63eccb93a61129e6e6dec2db5f5b1f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eccb93a61129e6e6dec2db5f5b1f2b">&#9670;&nbsp;</a></span>receive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::receive </td>
          <td>(</td>
          <td class="paramtype">MessageType *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves and removes the next message from the message queue. </p>
<p>If there are currently no messages in the queue, then the current thread will block until a message becomes available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, the message is removed from the queue but not returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f50c208f75ad2937d11d7eca8fdb6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f50c208f75ad2937d11d7eca8fdb6f0">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const MessageType &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>message to send </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab604a8c153f7f918762abc7f2380396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab604a8c153f7f918762abc7f2380396">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of messages currently in the queue. </p>
<p>This method should be used sparingly, since messages could be added/removed during or immediately after the call, making the result potentially unreliable.</p>
<dl class="section return"><dt>Returns</dt><dd>number of messages </dd></dl>

</div>
</div>
<a id="a344d81de71e73ab318d2bf4a4a852a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344d81de71e73ab318d2bf4a4a852a1b">&#9670;&nbsp;</a></span>try_peek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::try_peek </td>
          <td>(</td>
          <td class="paramtype">MessageType *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to peek at the message without blocking. </p>
<p>Populates memory pointed to by <code>out</code> with the next message in the queue. If there are no messages, then this will return immediately without peeking. The message will remain in the queue for the next <code>peek</code> or <code>receive</code> operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, nothing happens. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if message was successfully peeked, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a62077115caee87a6eccd527924015748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62077115caee87a6eccd527924015748">&#9670;&nbsp;</a></span>try_peek_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::try_peek_for </td>
          <td>(</td>
          <td class="paramtype">MessageType *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to peek at the next message, will wait for a maximum amount of time before aborting. </p>
<p>If it is not possible to peek at the next message immediately, then the current thread will block until either a message becomes available, or a timeout period has elapsed. The message will remain in the queue for the next <code>peek</code> or <code>receive</code> operation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>duration representation </td></tr>
    <tr><td class="paramname">Period</td><td>duration period </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, nothing happens </td></tr>
    <tr><td class="paramname">rel_time</td><td>relative timeout time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if message successfully peeked, <code>false</code> if timeout elapsed </dd></dl>

</div>
</div>
<a id="ae518346095033df725270dfeb866cdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae518346095033df725270dfeb866cdb4">&#9670;&nbsp;</a></span>try_peek_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<div class="memtemplate">
template&lt;typename Clock , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::try_peek_until </td>
          <td>(</td>
          <td class="paramtype">MessageType *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to peek at the next message, will wait for a maximum timeout time before aborting. </p>
<p>If it is not possible to peek at the next message immediately, then the current thread will block until either a message becomes available, or a timeout time has been reached. The message will remain in the queue for the next <code>peek</code> or <code>receive</code> operation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Clock</td><td>clock type </td></tr>
    <tr><td class="paramname">Duration</td><td>clock duration type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, nothing happens </td></tr>
    <tr><td class="paramname">timeout</td><td>absolute timeout time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if message successfully peeked, <code>false</code> if timeout </dd></dl>

</div>
</div>
<a id="ae42a9bd9edc9753a38fa63f20a34cc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42a9bd9edc9753a38fa63f20a34cc60">&#9670;&nbsp;</a></span>try_receive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::try_receive </td>
          <td>(</td>
          <td class="paramtype">MessageType *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to receive a message without blocking. </p>
<p>Populates memory pointed to by <code>out</code> with the next message, and removes the message from the queue. If there are no messages, then this will return immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, the message is removed but not returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a message is returned, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a4264047863208a01109569f62d093885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4264047863208a01109569f62d093885">&#9670;&nbsp;</a></span>try_receive_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::try_receive_for </td>
          <td>(</td>
          <td class="paramtype">MessageType *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to receive a message, will wait for a maximum amount of time before aborting. </p>
<p>If it is not possible to receive a message immediately, then the current thread will block until either a message becomes available, or a timeout period has elapsed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>duration representation </td></tr>
    <tr><td class="paramname">Period</td><td>duration period </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, the next message is removed but not returned </td></tr>
    <tr><td class="paramname">rel_time</td><td>relative timeout time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if message successfully returned, <code>false</code> if timeout elapsed </dd></dl>

</div>
</div>
<a id="abf193426822dfbb27fc1ce972db42da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf193426822dfbb27fc1ce972db42da0">&#9670;&nbsp;</a></span>try_receive_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<div class="memtemplate">
template&lt;typename Clock , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::try_receive_until </td>
          <td>(</td>
          <td class="paramtype">MessageType *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to receive a message, will wait for a maximum timeout time to be reached before aborting. </p>
<p>If it is not possible to receive a message immediately, then the current thread will block until either a message becomes available, or a timeout time has been reached.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Clock</td><td>clock type </td></tr>
    <tr><td class="paramname">Duration</td><td>clock duration type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, the next message is removed but not returned </td></tr>
    <tr><td class="paramname">timeout</td><td>absolute timeout time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if message successfully returned, <code>false</code> if timeout </dd></dl>

</div>
</div>
<a id="ae632a2b200bdac5bc93039b9bcb3d7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae632a2b200bdac5bc93039b9bcb3d7f5">&#9670;&nbsp;</a></span>try_send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::try_send </td>
          <td>(</td>
          <td class="paramtype">const MessageType &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to send a message without blocking. </p>
<p>If it is not possible to send the message without blocking, then will return immediately without sending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>message to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if message sent successfully, <code>false</code> if not sent </dd></dl>

</div>
</div>
<a id="a5242a6193a42e68e36634846f09c5e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5242a6193a42e68e36634846f09c5e3b">&#9670;&nbsp;</a></span>try_send_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::try_send_for </td>
          <td>(</td>
          <td class="paramtype">const MessageType &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to send a message, will wait for a maximum amount of time before aborting. </p>
<p>If it is not possible to send the message immediately, then the current thread will block until either the message is sent successfully, or a timeout period has elapsed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>timeout duration representation </td></tr>
    <tr><td class="paramname">Period</td><td>timeout duration period </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>message to send </td></tr>
    <tr><td class="paramname">rel_time</td><td>relative timeout time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the message is sent successfully within the timeout period, <code>false</code> if not sent </dd></dl>

</div>
</div>
<a id="ab13d8f1c89ca9022e5446b3fc5432072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13d8f1c89ca9022e5446b3fc5432072">&#9670;&nbsp;</a></span>try_send_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<div class="memtemplate">
template&lt;typename Clock , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::try_send_until </td>
          <td>(</td>
          <td class="paramtype">const MessageType &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to send a message, will wait until a timeout time has been reached before aborting. </p>
<p>If it is not possible to send the message immediately, then the current thread will block until either the message is sent successfully, or an absolute timeout time has been reached.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Clock</td><td>timeout clock type </td></tr>
    <tr><td class="paramname">Duration</td><td>timeout duration type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>message to send </td></tr>
    <tr><td class="paramname">timeout</td><td>absolute timeout time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if message sent successfully before timeout time has passed, <code>false</code> if message not sent </dd></dl>

</div>
</div>
<a id="ae94a6503dff948dfc2533f7786839dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94a6503dff948dfc2533f7786839dca">&#9670;&nbsp;</a></span>unlink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::unlink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches the name from the named resource. </p>
<p>On POSIX systems, named resources will persist beyond the lifetime of any process that uses them as long as the name has not been unlinked (or until the system is rebooted). Calling <code>unlink</code> will detach the name, allowing the resource to be freed once all current users have exited.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if unlink is successful, <code>false</code> if unlinking is not supported or if an error has occurred. </dd></dl>

<p>Implements <a class="el" href="classcpen333_1_1process_1_1named__resource.html#a5d33168fee48c9b0c58ab8fd96e230ce">cpen333::process::named_resource</a>.</p>

</div>
</div>
<a id="aca172436d5b30c250c301d3c224598b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca172436d5b30c250c301d3c224598b6">&#9670;&nbsp;</a></span>unlink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classcpen333_1_1process_1_1message__queue.html">cpen333::process::message_queue</a>&lt; MessageType &gt;::unlink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlinks the name without needing to create a resource. </p>
<p>Implementers should also provide a static method for unlinking. The purpose is mainly for clean-up of existing resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>desired resource name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if unlink successful, <code>false</code> if not successful or not supported </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/school/teaching/CPEN333/workspace/library/include/cpen333/process/<a class="el" href="message__queue_8h_source.html">message_queue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
