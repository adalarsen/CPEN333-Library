<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CPEN333: Process and Threads Library: cpen333::process::fifo&lt; ValueType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CPEN333: Process and Threads Library
   &#160;<span id="projectnumber">1.1</span>
   </div>
   <div id="projectbrief">Cross-platform library for inter-process and inter-thread synchronization and communication</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cpen333</b></li><li class="navelem"><b>process</b></li><li class="navelem"><a class="el" href="classcpen333_1_1process_1_1fifo.html">fifo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcpen333_1_1process_1_1fifo-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cpen333::process::fifo&lt; ValueType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Simple thread-safe multi-process first-in-first-out queue using a circular buffer.  
 <a href="classcpen333_1_1process_1_1fifo.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="process_2fifo_8h_source.html">fifo.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cpen333::process::fifo&lt; ValueType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcpen333_1_1process_1_1fifo.png" usemap="#cpen333::process::fifo_3C_20ValueType_20_3E_map" alt=""/>
  <map id="cpen333::process::fifo_3C_20ValueType_20_3E_map" name="cpen333::process::fifo_3C_20ValueType_20_3E_map">
<area href="classcpen333_1_1process_1_1named__resource.html" title="Pure virtual base class for all inter-process resources. " alt="cpen333::process::named_resource" shape="rect" coords="0,0,221,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abc26c9f811226c81d390bd32dd4a3a53"><td class="memItemLeft" align="right" valign="top"><a id="abc26c9f811226c81d390bd32dd4a3a53"></a>
typedef ValueType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#abc26c9f811226c81d390bd32dd4a3a53">value_type</a></td></tr>
<tr class="memdesc:abc26c9f811226c81d390bd32dd4a3a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">data type stored in buffer <br /></td></tr>
<tr class="separator:abc26c9f811226c81d390bd32dd4a3a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abbac3b7b35974927626c0fc96540a5c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#abbac3b7b35974927626c0fc96540a5c9">fifo</a> (const std::string &amp;name, size_t <a class="el" href="classcpen333_1_1process_1_1fifo.html#aeaf7bd6333245fad222fcf088e589ad6">size</a>=1024)</td></tr>
<tr class="memdesc:abbac3b7b35974927626c0fc96540a5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates or connects to an existing named fifo.  <a href="#abbac3b7b35974927626c0fc96540a5c9">More...</a><br /></td></tr>
<tr class="separator:abbac3b7b35974927626c0fc96540a5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169331a45d9b30c6303ab8300b7901e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#a169331a45d9b30c6303ab8300b7901e8">push</a> (const ValueType &amp;val)</td></tr>
<tr class="memdesc:a169331a45d9b30c6303ab8300b7901e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a item to the fifo.  <a href="#a169331a45d9b30c6303ab8300b7901e8">More...</a><br /></td></tr>
<tr class="separator:a169331a45d9b30c6303ab8300b7901e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a7fb652df17c022023fcc805ba61eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#ad6a7fb652df17c022023fcc805ba61eb">try_push</a> (const ValueType &amp;val)</td></tr>
<tr class="memdesc:ad6a7fb652df17c022023fcc805ba61eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to add an item to the fifo without blocking.  <a href="#ad6a7fb652df17c022023fcc805ba61eb">More...</a><br /></td></tr>
<tr class="separator:ad6a7fb652df17c022023fcc805ba61eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2904c1ed9d23f0d7fd034216c5509688"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a2904c1ed9d23f0d7fd034216c5509688"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#a2904c1ed9d23f0d7fd034216c5509688">try_push_for</a> (const ValueType &amp;val, std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</td></tr>
<tr class="memdesc:a2904c1ed9d23f0d7fd034216c5509688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to add an item to the fifo, will wait for a maximum amount of time before aborting.  <a href="#a2904c1ed9d23f0d7fd034216c5509688">More...</a><br /></td></tr>
<tr class="separator:a2904c1ed9d23f0d7fd034216c5509688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9fee85225689f4104f263510814db0"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename Duration &gt; </td></tr>
<tr class="memitem:abe9fee85225689f4104f263510814db0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#abe9fee85225689f4104f263510814db0">try_push_until</a> (const ValueType &amp;val, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout)</td></tr>
<tr class="memdesc:abe9fee85225689f4104f263510814db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to add an item to the fifo, will wait until a timeout time is reached before aborting.  <a href="#abe9fee85225689f4104f263510814db0">More...</a><br /></td></tr>
<tr class="separator:abe9fee85225689f4104f263510814db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29e5bd6d8b0fe551c4d7532ffcb331e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#af29e5bd6d8b0fe551c4d7532ffcb331e">pop</a> (ValueType *out)</td></tr>
<tr class="memdesc:af29e5bd6d8b0fe551c4d7532ffcb331e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the next item in the fifo.  <a href="#af29e5bd6d8b0fe551c4d7532ffcb331e">More...</a><br /></td></tr>
<tr class="separator:af29e5bd6d8b0fe551c4d7532ffcb331e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40796c0eb39299ff4f8c49a789268386"><td class="memItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#a40796c0eb39299ff4f8c49a789268386">pop</a> ()</td></tr>
<tr class="memdesc:a40796c0eb39299ff4f8c49a789268386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the next item in the fifo.  <a href="#a40796c0eb39299ff4f8c49a789268386">More...</a><br /></td></tr>
<tr class="separator:a40796c0eb39299ff4f8c49a789268386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3e1f84d8a72e620f44bc5c018b3a9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#a6f3e1f84d8a72e620f44bc5c018b3a9c">try_pop</a> (ValueType *out)</td></tr>
<tr class="memdesc:a6f3e1f84d8a72e620f44bc5c018b3a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to remove and return the next item in the fifo without blocking.  <a href="#a6f3e1f84d8a72e620f44bc5c018b3a9c">More...</a><br /></td></tr>
<tr class="separator:a6f3e1f84d8a72e620f44bc5c018b3a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6411f9f377c2be43500bc53883651120"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a6411f9f377c2be43500bc53883651120"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#a6411f9f377c2be43500bc53883651120">try_pop_for</a> (ValueType *out, std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</td></tr>
<tr class="memdesc:a6411f9f377c2be43500bc53883651120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to remove an item from the fifo, will wait for a maximum amount of time before aborting.  <a href="#a6411f9f377c2be43500bc53883651120">More...</a><br /></td></tr>
<tr class="separator:a6411f9f377c2be43500bc53883651120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e66a7f6e91c0725ad6a5f3940668e64"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename Duration &gt; </td></tr>
<tr class="memitem:a7e66a7f6e91c0725ad6a5f3940668e64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#a7e66a7f6e91c0725ad6a5f3940668e64">try_pop_until</a> (ValueType *out, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout)</td></tr>
<tr class="memdesc:a7e66a7f6e91c0725ad6a5f3940668e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to remove an item from the fifo, will wait for a maximum timeout time to be reached before aborting.  <a href="#a7e66a7f6e91c0725ad6a5f3940668e64">More...</a><br /></td></tr>
<tr class="separator:a7e66a7f6e91c0725ad6a5f3940668e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac501e62c2253097f89d713558d888d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#ac501e62c2253097f89d713558d888d16">peek</a> (ValueType *out)</td></tr>
<tr class="memdesc:ac501e62c2253097f89d713558d888d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks at the next item in the fifo without removing it.  <a href="#ac501e62c2253097f89d713558d888d16">More...</a><br /></td></tr>
<tr class="separator:ac501e62c2253097f89d713558d888d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785266ee082e1917198bd0d701b25e50"><td class="memItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#a785266ee082e1917198bd0d701b25e50">peek</a> ()</td></tr>
<tr class="memdesc:a785266ee082e1917198bd0d701b25e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks at the next item in the fifo without removing it.  <a href="#a785266ee082e1917198bd0d701b25e50">More...</a><br /></td></tr>
<tr class="separator:a785266ee082e1917198bd0d701b25e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0518230659a2ec8568f05377f4e2e727"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#a0518230659a2ec8568f05377f4e2e727">try_peek</a> (ValueType *out)</td></tr>
<tr class="memdesc:a0518230659a2ec8568f05377f4e2e727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to peek at the next item in the fifo without blocking.  <a href="#a0518230659a2ec8568f05377f4e2e727">More...</a><br /></td></tr>
<tr class="separator:a0518230659a2ec8568f05377f4e2e727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d351911485a6cef80404da4aa663ec"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a61d351911485a6cef80404da4aa663ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#a61d351911485a6cef80404da4aa663ec">try_peek_for</a> (ValueType *out, std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time)</td></tr>
<tr class="memdesc:a61d351911485a6cef80404da4aa663ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to peek at the next item in the fifo, will wait for a maximum amount of time before aborting.  <a href="#a61d351911485a6cef80404da4aa663ec">More...</a><br /></td></tr>
<tr class="separator:a61d351911485a6cef80404da4aa663ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac587ec4df8ae29b25a3e21ac7114e335"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename Duration &gt; </td></tr>
<tr class="memitem:ac587ec4df8ae29b25a3e21ac7114e335"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#ac587ec4df8ae29b25a3e21ac7114e335">try_peek_until</a> (ValueType *out, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout)</td></tr>
<tr class="memdesc:ac587ec4df8ae29b25a3e21ac7114e335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to peek at the next item in the fifo, will wait for a maximum timeout time before aborting.  <a href="#ac587ec4df8ae29b25a3e21ac7114e335">More...</a><br /></td></tr>
<tr class="separator:ac587ec4df8ae29b25a3e21ac7114e335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf7bd6333245fad222fcf088e589ad6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#aeaf7bd6333245fad222fcf088e589ad6">size</a> ()</td></tr>
<tr class="memdesc:aeaf7bd6333245fad222fcf088e589ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of items currently in the fifo.  <a href="#aeaf7bd6333245fad222fcf088e589ad6">More...</a><br /></td></tr>
<tr class="separator:aeaf7bd6333245fad222fcf088e589ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ce36a0885d0c3ded0997ec2586aabe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#ae2ce36a0885d0c3ded0997ec2586aabe">empty</a> ()</td></tr>
<tr class="memdesc:ae2ce36a0885d0c3ded0997ec2586aabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if fifo queue is currently empty.  <a href="#ae2ce36a0885d0c3ded0997ec2586aabe">More...</a><br /></td></tr>
<tr class="separator:ae2ce36a0885d0c3ded0997ec2586aabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f9c252de8044d57568e99b64cbb860"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#a85f9c252de8044d57568e99b64cbb860">unlink</a> ()</td></tr>
<tr class="memdesc:a85f9c252de8044d57568e99b64cbb860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the name from the named resource.  <a href="#a85f9c252de8044d57568e99b64cbb860">More...</a><br /></td></tr>
<tr class="separator:a85f9c252de8044d57568e99b64cbb860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcpen333_1_1process_1_1named__resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcpen333_1_1process_1_1named__resource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcpen333_1_1process_1_1named__resource.html">cpen333::process::named_resource</a></td></tr>
<tr class="memitem:a2bf88d9fa295c5e9ffecf2a43414e6da inherit pub_methods_classcpen333_1_1process_1_1named__resource"><td class="memItemLeft" align="right" valign="top"><a id="a2bf88d9fa295c5e9ffecf2a43414e6da"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1named__resource.html#a2bf88d9fa295c5e9ffecf2a43414e6da">~named_resource</a> ()</td></tr>
<tr class="memdesc:a2bf88d9fa295c5e9ffecf2a43414e6da inherit pub_methods_classcpen333_1_1process_1_1named__resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:a2bf88d9fa295c5e9ffecf2a43414e6da inherit pub_methods_classcpen333_1_1process_1_1named__resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a893a14908a88de202fe2804dd890f958"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1fifo.html#a893a14908a88de202fe2804dd890f958">unlink</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a893a14908a88de202fe2804dd890f958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the name without needing to create a resource.  <a href="#a893a14908a88de202fe2804dd890f958">More...</a><br /></td></tr>
<tr class="separator:a893a14908a88de202fe2804dd890f958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classcpen333_1_1process_1_1named__resource"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classcpen333_1_1process_1_1named__resource')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classcpen333_1_1process_1_1named__resource.html">cpen333::process::named_resource</a></td></tr>
<tr class="memitem:a6cb427f033b51f08fcf2bc1e08bd6a32 inherit pub_static_methods_classcpen333_1_1process_1_1named__resource"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpen333_1_1process_1_1named__resource.html#a6cb427f033b51f08fcf2bc1e08bd6a32">unlink</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6cb427f033b51f08fcf2bc1e08bd6a32 inherit pub_static_methods_classcpen333_1_1process_1_1named__resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the name without needing to create a resource.  <a href="classcpen333_1_1process_1_1named__resource.html#a6cb427f033b51f08fcf2bc1e08bd6a32">More...</a><br /></td></tr>
<tr class="separator:a6cb427f033b51f08fcf2bc1e08bd6a32 inherit pub_static_methods_classcpen333_1_1process_1_1named__resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ValueType&gt;<br />
class cpen333::process::fifo&lt; ValueType &gt;</h3>

<p>Simple thread-safe multi-process first-in-first-out queue using a circular buffer. </p>
<p>The buffer can only contain a single type of object. Push will block until space is available in the queue. Pop will block until there is an item in the queue. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>type of data to store in the queue </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abbac3b7b35974927626c0fc96540a5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbac3b7b35974927626c0fc96540a5c9">&#9670;&nbsp;</a></span>fifo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::<a class="el" href="classcpen333_1_1process_1_1fifo.html">fifo</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates or connects to an existing named fifo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name identifier for creating or connecting to an existing inter-process fifo </td></tr>
    <tr><td class="paramname">size</td><td>if creating, the maximum number of elements that can be stored in the queue without blocking </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae2ce36a0885d0c3ded0997ec2586aabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ce36a0885d0c3ded0997ec2586aabe">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if fifo queue is currently empty. </p>
<p>This method should be used sparingly, since items could be added/removed during or immediately after the call, making the result potentially unreliable</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if empty, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ac501e62c2253097f89d713558d888d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac501e62c2253097f89d713558d888d16">&#9670;&nbsp;</a></span>peek() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::peek </td>
          <td>(</td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peeks at the next item in the fifo without removing it. </p>
<p>Populates memory pointed to by <code>out</code> with next item in fifo. If there are currently no items, this method will block until an item becomes available. The item will remain in the fifo for the next <code>peek</code> or <code>pop</code> operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, nothing happens. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a785266ee082e1917198bd0d701b25e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785266ee082e1917198bd0d701b25e50">&#9670;&nbsp;</a></span>peek() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peeks at the next item in the fifo without removing it. </p>
<p>Returns the next item in the fifo. If there are currently no items, this method will block until one becomes available. The item will remain in the fifo for the next <code>peek</code> or <code>pop</code> operation.</p>
<dl class="section return"><dt>Returns</dt><dd>next item in the fifo. </dd></dl>

</div>
</div>
<a id="af29e5bd6d8b0fe551c4d7532ffcb331e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29e5bd6d8b0fe551c4d7532ffcb331e">&#9670;&nbsp;</a></span>pop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the next item in the fifo. </p>
<p>Populates memory pointed to by <code>out</code> with next item in the fifo. If there are no items in the fifo, then this will block until one is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, item is removed but not returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40796c0eb39299ff4f8c49a789268386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40796c0eb39299ff4f8c49a789268386">&#9670;&nbsp;</a></span>pop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes and returns the next item in the fifo. </p>
<p>If there are no items in the fifo, then this will block until one is available.</p>
<dl class="section return"><dt>Returns</dt><dd>next item in the fifo </dd></dl>

</div>
</div>
<a id="a169331a45d9b30c6303ab8300b7901e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169331a45d9b30c6303ab8300b7901e8">&#9670;&nbsp;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a item to the fifo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeaf7bd6333245fad222fcf088e589ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf7bd6333245fad222fcf088e589ad6">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of items currently in the fifo. </p>
<p>This method should be used sparingly, since items could be added/removed during or immediately after the call, making the result potentially unreliable.</p>
<dl class="section return"><dt>Returns</dt><dd>number of items </dd></dl>

</div>
</div>
<a id="a0518230659a2ec8568f05377f4e2e727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0518230659a2ec8568f05377f4e2e727">&#9670;&nbsp;</a></span>try_peek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::try_peek </td>
          <td>(</td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to peek at the next item in the fifo without blocking. </p>
<p>Populates memory pointed to by <code>out</code> with the next item in the fifo. If there are no items, then this will return immediately without peeking at the item. The item will remain in the fifo for the next <code>peek</code> or <code>pop</code> operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, nothing happens. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item was successfully peeked, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a61d351911485a6cef80404da4aa663ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d351911485a6cef80404da4aa663ec">&#9670;&nbsp;</a></span>try_peek_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::try_peek_for </td>
          <td>(</td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to peek at the next item in the fifo, will wait for a maximum amount of time before aborting. </p>
<p>If it is not possible to peek at an item in the fifo immediately, then the current thread will block until either an item becomes available, or a timeout period has elapsed. The item will remain in the fifo for the next <code>peek</code> or <code>pop</code> operation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>duration representation </td></tr>
    <tr><td class="paramname">Period</td><td>duration period </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, nothing happens </td></tr>
    <tr><td class="paramname">rel_time</td><td>relative timeout time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item successfully peeked, <code>false</code> if timeout elapsed </dd></dl>

</div>
</div>
<a id="ac587ec4df8ae29b25a3e21ac7114e335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac587ec4df8ae29b25a3e21ac7114e335">&#9670;&nbsp;</a></span>try_peek_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<div class="memtemplate">
template&lt;typename Clock , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::try_peek_until </td>
          <td>(</td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to peek at the next item in the fifo, will wait for a maximum timeout time before aborting. </p>
<p>If it is not possible to peek at the next item in the fifo immediately, then the current thread will block until either an item becomes available, or a timeout time has been reached. The item will remain in the fifo for the next <code>peek</code> or <code>pop</code> operation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Clock</td><td>clock type </td></tr>
    <tr><td class="paramname">Duration</td><td>clock duration type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, nothing happens </td></tr>
    <tr><td class="paramname">timeout</td><td>absolute timeout time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item successfully peeked, <code>false</code> if timeout </dd></dl>

</div>
</div>
<a id="a6f3e1f84d8a72e620f44bc5c018b3a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3e1f84d8a72e620f44bc5c018b3a9c">&#9670;&nbsp;</a></span>try_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::try_pop </td>
          <td>(</td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to remove and return the next item in the fifo without blocking. </p>
<p>Populates memory pointed to by <code>out</code> with the next item in the fifo. If there are no items, then this will return immediately without popping the item.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, the item is removed but not returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item was successfully popped, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a6411f9f377c2be43500bc53883651120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6411f9f377c2be43500bc53883651120">&#9670;&nbsp;</a></span>try_pop_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::try_pop_for </td>
          <td>(</td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to remove an item from the fifo, will wait for a maximum amount of time before aborting. </p>
<p>If it is not possible to remove an item from the fifo immediately, then the current thread will block until either an item becomes available, or a timeout period has elapsed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>duration representation </td></tr>
    <tr><td class="paramname">Period</td><td>duration period </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, the item is removed but not returned </td></tr>
    <tr><td class="paramname">rel_time</td><td>relative timeout time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item successfully popped, <code>false</code> if timeout elapsed </dd></dl>

</div>
</div>
<a id="a7e66a7f6e91c0725ad6a5f3940668e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e66a7f6e91c0725ad6a5f3940668e64">&#9670;&nbsp;</a></span>try_pop_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<div class="memtemplate">
template&lt;typename Clock , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::try_pop_until </td>
          <td>(</td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to remove an item from the fifo, will wait for a maximum timeout time to be reached before aborting. </p>
<p>If it is not possible to remove an item from the fifo immediately, then the current thread will block until either an item becomes available, or a timeout time has been reached.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Clock</td><td>clock type </td></tr>
    <tr><td class="paramname">Duration</td><td>clock duration type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>destination. If <code>nullptr</code>, the item is removed but not returned </td></tr>
    <tr><td class="paramname">timeout</td><td>absolute timeout time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item successfully popped, <code>false</code> if timeout </dd></dl>

</div>
</div>
<a id="ad6a7fb652df17c022023fcc805ba61eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a7fb652df17c022023fcc805ba61eb">&#9670;&nbsp;</a></span>try_push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::try_push </td>
          <td>(</td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to add an item to the fifo without blocking. </p>
<p>If it is not possible to add to the fifo without blocking, then will return immediately without adding the item.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>item to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item is added, <code>false</code> if would cause the current thread to block </dd></dl>

</div>
</div>
<a id="a2904c1ed9d23f0d7fd034216c5509688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2904c1ed9d23f0d7fd034216c5509688">&#9670;&nbsp;</a></span>try_push_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::try_push_for </td>
          <td>(</td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to add an item to the fifo, will wait for a maximum amount of time before aborting. </p>
<p>If it is not possible to add the item to the fifo immediately, then the current thread will block until either the item is added successfully, or a timeout period has elapsed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>duration representation </td></tr>
    <tr><td class="paramname">Period</td><td>duration period </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to add to the fifo </td></tr>
    <tr><td class="paramname">rel_time</td><td>relative timeout time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item added within the timeout time, <code>false</code> if not added </dd></dl>

</div>
</div>
<a id="abe9fee85225689f4104f263510814db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9fee85225689f4104f263510814db0">&#9670;&nbsp;</a></span>try_push_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<div class="memtemplate">
template&lt;typename Clock , typename Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::try_push_until </td>
          <td>(</td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to add an item to the fifo, will wait until a timeout time is reached before aborting. </p>
<p>If it is not possible to add the item to the fifo immediately, then the current thread will block until either the item is added successfully, or an absolute timeout time has been reached.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Clock</td><td>clock type </td></tr>
    <tr><td class="paramname">Duration</td><td>clock duration type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value to add to the fifo </td></tr>
    <tr><td class="paramname">timeout</td><td>absolute timeout time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if item added before the timeout time, <code>false</code> if not added </dd></dl>

</div>
</div>
<a id="a85f9c252de8044d57568e99b64cbb860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f9c252de8044d57568e99b64cbb860">&#9670;&nbsp;</a></span>unlink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::unlink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches the name from the named resource. </p>
<p>On POSIX systems, named resources will persist beyond the lifetime of any process that uses them as long as the name has not been unlinked (or until the system is rebooted). Calling <code>unlink</code> will detach the name, allowing the resource to be freed once all current users have exited.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if unlink is successful, <code>false</code> if unlinking is not supported or if an error has occurred. </dd></dl>

<p>Implements <a class="el" href="classcpen333_1_1process_1_1named__resource.html#a5d33168fee48c9b0c58ab8fd96e230ce">cpen333::process::named_resource</a>.</p>

</div>
</div>
<a id="a893a14908a88de202fe2804dd890f958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893a14908a88de202fe2804dd890f958">&#9670;&nbsp;</a></span>unlink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classcpen333_1_1process_1_1fifo.html">cpen333::process::fifo</a>&lt; ValueType &gt;::unlink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlinks the name without needing to create a resource. </p>
<p>Implementers should also provide a static method for unlinking. The purpose is mainly for clean-up of existing resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>desired resource name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if unlink successful, <code>false</code> if not successful or not supported </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/school/teaching/CPEN333/workspace/library/include/cpen333/process/<a class="el" href="process_2fifo_8h_source.html">fifo.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
